/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/JavaEmitter.java on Tue Aug 27 12:18:51 KST 2024 ----! */
/* !---- Java-Unit: [pkg org.prismatic.kotlinangle, cls AngleNative], output/gensrc/java/org/prismatic/kotlinangle/AngleNative.java ----! */

package org.prismatic.kotlinangle;

import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;
import com.jogamp.common.util.*;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

public class AngleNative {

  /** Defined as part of enum type "khronos_boolean_enum_t" with expression '<code>0</code>', CType: int */
  public static final int KHRONOS_FALSE = 0x0;
  /** Defined as part of enum type "khronos_boolean_enum_t" with expression '<code>1</code>', CType: int */
  public static final int KHRONOS_TRUE = 0x1;
  /** Defined as part of enum type "khronos_boolean_enum_t" with expression '<code>0x7FFFFFFF</code>', CType: int */
  public static final int KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 0x7fffffff;
  /** Define "GL_CW" with expression '<code>0x0900</code>', CType: int */
  public static final int GL_CW = 0x900;
  /** Define "GL_ALIASED_POINT_SIZE_RANGE" with expression '<code>0x846D</code>', CType: int */
  public static final int GL_ALIASED_POINT_SIZE_RANGE = 0x846d;
  /** Define "GL_MAX_CUBE_MAP_TEXTURE_SIZE" with expression '<code>0x851C</code>', CType: int */
  public static final int GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851c;
  /** Define "GL_LEQUAL" with expression '<code>0x0203</code>', CType: int */
  public static final int GL_LEQUAL = 0x203;
  /** Define "GL_LOW_FLOAT" with expression '<code>0x8DF0</code>', CType: int */
  public static final int GL_LOW_FLOAT = 0x8df0;
  /** Define "GL_ONE_MINUS_SRC_COLOR" with expression '<code>0x0301</code>', CType: int */
  public static final int GL_ONE_MINUS_SRC_COLOR = 0x301;
  /** Define "GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS" with expression '<code>0x8CD9</code>', CType: int */
  public static final int GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8cd9;
  /** Define "GL_ACTIVE_ATTRIBUTE_MAX_LENGTH" with expression '<code>0x8B8A</code>', CType: int */
  public static final int GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8b8a;
  /** Define "GL_SCISSOR_TEST" with expression '<code>0x0C11</code>', CType: int */
  public static final int GL_SCISSOR_TEST = 0xc11;
  /** Define "GL_ARRAY_BUFFER_BINDING" with expression '<code>0x8894</code>', CType: int */
  public static final int GL_ARRAY_BUFFER_BINDING = 0x8894;
  /** Define "GL_UNSIGNED_INT" with expression '<code>0x1405</code>', CType: int */
  public static final int GL_UNSIGNED_INT = 0x1405;
  /** Define "GL_ONE_MINUS_DST_COLOR" with expression '<code>0x0307</code>', CType: int */
  public static final int GL_ONE_MINUS_DST_COLOR = 0x307;
  /** Define "GL_DELETE_STATUS" with expression '<code>0x8B80</code>', CType: int */
  public static final int GL_DELETE_STATUS = 0x8b80;
  /** Define "GL_GREEN_BITS" with expression '<code>0x0D53</code>', CType: int */
  public static final int GL_GREEN_BITS = 0xd53;
  /** Define "GL_ACTIVE_UNIFORMS" with expression '<code>0x8B86</code>', CType: int */
  public static final int GL_ACTIVE_UNIFORMS = 0x8b86;
  /** Define "GL_FRAMEBUFFER_COMPLETE" with expression '<code>0x8CD5</code>', CType: int */
  public static final int GL_FRAMEBUFFER_COMPLETE = 0x8cd5;
  /** Define "GL_VENDOR" with expression '<code>0x1F00</code>', CType: int */
  public static final int GL_VENDOR = 0x1f00;
  /** Define "GL_CURRENT_VERTEX_ATTRIB" with expression '<code>0x8626</code>', CType: int */
  public static final int GL_CURRENT_VERTEX_ATTRIB = 0x8626;
  /** Define "GL_ALIASED_LINE_WIDTH_RANGE" with expression '<code>0x846E</code>', CType: int */
  public static final int GL_ALIASED_LINE_WIDTH_RANGE = 0x846e;
  /** Define "GL_RENDERBUFFER_BINDING" with expression '<code>0x8CA7</code>', CType: int */
  public static final int GL_RENDERBUFFER_BINDING = 0x8ca7;
  /** Define "GL_INVALID_ENUM" with expression '<code>0x0500</code>', CType: int */
  public static final int GL_INVALID_ENUM = 0x500;
  /** Define "GL_RED_BITS" with expression '<code>0x0D52</code>', CType: int */
  public static final int GL_RED_BITS = 0xd52;
  /** Define "GL_CCW" with expression '<code>0x0901</code>', CType: int */
  public static final int GL_CCW = 0x901;
  /** Define "GL_SHORT" with expression '<code>0x1402</code>', CType: int */
  public static final int GL_SHORT = 0x1402;
  /** Define "GL_VERTEX_SHADER" with expression '<code>0x8B31</code>', CType: int */
  public static final int GL_VERTEX_SHADER = 0x8b31;
  /** Define "GL_COLOR_BUFFER_BIT" with expression '<code>0x00004000</code>', CType: int */
  public static final int GL_COLOR_BUFFER_BIT = 0x4000;
  /** Define "GL_STENCIL_REF" with expression '<code>0x0B97</code>', CType: int */
  public static final int GL_STENCIL_REF = 0xb97;
  /** Define "GL_INFO_LOG_LENGTH" with expression '<code>0x8B84</code>', CType: int */
  public static final int GL_INFO_LOG_LENGTH = 0x8b84;
  /** Define "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL" with expression '<code>0x8CD2</code>', CType: int */
  public static final int GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8cd2;
  /** Define "GL_DEPTH_ATTACHMENT" with expression '<code>0x8D00</code>', CType: int */
  public static final int GL_DEPTH_ATTACHMENT = 0x8d00;
  /** Define "GL_SHADER_COMPILER" with expression '<code>0x8DFA</code>', CType: int */
  public static final int GL_SHADER_COMPILER = 0x8dfa;
  /** Define "GL_TEXTURE" with expression '<code>0x1702</code>', CType: int */
  public static final int GL_TEXTURE = 0x1702;
  /** Define "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT" with expression '<code>0x8CD7</code>', CType: int */
  public static final int GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8cd7;
  /** Define "GL_TEXTURE_CUBE_MAP" with expression '<code>0x8513</code>', CType: int */
  public static final int GL_TEXTURE_CUBE_MAP = 0x8513;
  /** Define "GL_NUM_SHADER_BINARY_FORMATS" with expression '<code>0x8DF9</code>', CType: int */
  public static final int GL_NUM_SHADER_BINARY_FORMATS = 0x8df9;
  /** Define "GL_ALWAYS" with expression '<code>0x0207</code>', CType: int */
  public static final int GL_ALWAYS = 0x207;
  /** Define "GL_SAMPLE_COVERAGE_VALUE" with expression '<code>0x80AA</code>', CType: int */
  public static final int GL_SAMPLE_COVERAGE_VALUE = 0x80aa;
  /** Define "GL_INVALID_FRAMEBUFFER_OPERATION" with expression '<code>0x0506</code>', CType: int */
  public static final int GL_INVALID_FRAMEBUFFER_OPERATION = 0x506;
  /** Define "GL_ONE_MINUS_DST_ALPHA" with expression '<code>0x0305</code>', CType: int */
  public static final int GL_ONE_MINUS_DST_ALPHA = 0x305;
  /** Define "GL_MAX_FRAGMENT_UNIFORM_VECTORS" with expression '<code>0x8DFD</code>', CType: int */
  public static final int GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8dfd;
  /** Define "GL_INVERT" with expression '<code>0x150A</code>', CType: int */
  public static final int GL_INVERT = 0x150a;
  /** Define "GL_NEAREST" with expression '<code>0x2600</code>', CType: int */
  public static final int GL_NEAREST = 0x2600;
  /** Define "GL_RENDERBUFFER" with expression '<code>0x8D41</code>', CType: int */
  public static final int GL_RENDERBUFFER = 0x8d41;
  /** Define "GL_MAX_VERTEX_UNIFORM_VECTORS" with expression '<code>0x8DFB</code>', CType: int */
  public static final int GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8dfb;
  /** Define "GL_STENCIL_PASS_DEPTH_PASS" with expression '<code>0x0B96</code>', CType: int */
  public static final int GL_STENCIL_PASS_DEPTH_PASS = 0xb96;
  /** Define "GL_STENCIL_BACK_WRITEMASK" with expression '<code>0x8CA5</code>', CType: int */
  public static final int GL_STENCIL_BACK_WRITEMASK = 0x8ca5;
  /** Define "GL_TRUE" with expression '<code>1</code>', CType: int */
  public static final int GL_TRUE = 0x1;
  /** Define "GL_LINE_STRIP" with expression '<code>0x0003</code>', CType: int */
  public static final int GL_LINE_STRIP = 0x3;
  /** Define "GL_LUMINANCE" with expression '<code>0x1909</code>', CType: int */
  public static final int GL_LUMINANCE = 0x1909;
  /** Define "GL_DEPTH_TEST" with expression '<code>0x0B71</code>', CType: int */
  public static final int GL_DEPTH_TEST = 0xb71;
  /** Define "GL_INVALID_OPERATION" with expression '<code>0x0502</code>', CType: int */
  public static final int GL_INVALID_OPERATION = 0x502;
  /** Define "GL_FRAGMENT_SHADER" with expression '<code>0x8B30</code>', CType: int */
  public static final int GL_FRAGMENT_SHADER = 0x8b30;
  /** Define "GL_CULL_FACE" with expression '<code>0x0B44</code>', CType: int */
  public static final int GL_CULL_FACE = 0xb44;
  /** Define "GL_BLEND_EQUATION_ALPHA" with expression '<code>0x883D</code>', CType: int */
  public static final int GL_BLEND_EQUATION_ALPHA = 0x883d;
  /** Define "GL_BLEND_SRC_RGB" with expression '<code>0x80C9</code>', CType: int */
  public static final int GL_BLEND_SRC_RGB = 0x80c9;
  /** Define "GL_NO_ERROR" with expression '<code>0</code>', CType: int */
  public static final int GL_NO_ERROR = 0x0;
  /** Define "GL_FRONT_AND_BACK" with expression '<code>0x0408</code>', CType: int */
  public static final int GL_FRONT_AND_BACK = 0x408;
  /** Define "GL_DST_COLOR" with expression '<code>0x0306</code>', CType: int */
  public static final int GL_DST_COLOR = 0x306;
  /** Define "GL_VIEWPORT" with expression '<code>0x0BA2</code>', CType: int */
  public static final int GL_VIEWPORT = 0xba2;
  /** Define "GL_LESS" with expression '<code>0x0201</code>', CType: int */
  public static final int GL_LESS = 0x201;
  /** Define "GL_POLYGON_OFFSET_FACTOR" with expression '<code>0x8038</code>', CType: int */
  public static final int GL_POLYGON_OFFSET_FACTOR = 0x8038;
  /** Define "GL_LUMINANCE_ALPHA" with expression '<code>0x190A</code>', CType: int */
  public static final int GL_LUMINANCE_ALPHA = 0x190a;
  /** Define "GL_SHADER_BINARY_FORMATS" with expression '<code>0x8DF8</code>', CType: int */
  public static final int GL_SHADER_BINARY_FORMATS = 0x8df8;
  /** Define "GL_BLEND_COLOR" with expression '<code>0x8005</code>', CType: int */
  public static final int GL_BLEND_COLOR = 0x8005;
  /** Define "GL_STENCIL_VALUE_MASK" with expression '<code>0x0B93</code>', CType: int */
  public static final int GL_STENCIL_VALUE_MASK = 0xb93;
  /** Define "GL_DEPTH_COMPONENT" with expression '<code>0x1902</code>', CType: int */
  public static final int GL_DEPTH_COMPONENT = 0x1902;
  /** Define "GL_TEXTURE_WRAP_S" with expression '<code>0x2802</code>', CType: int */
  public static final int GL_TEXTURE_WRAP_S = 0x2802;
  /** Define "GL_DEPTH_CLEAR_VALUE" with expression '<code>0x0B73</code>', CType: int */
  public static final int GL_DEPTH_CLEAR_VALUE = 0xb73;
  /** Define "GL_TEXTURE_WRAP_T" with expression '<code>0x2803</code>', CType: int */
  public static final int GL_TEXTURE_WRAP_T = 0x2803;
  /** Define "GL_ONE" with expression '<code>1</code>', CType: int */
  public static final int GL_ONE = 0x1;
  /** Define "GL_GREATER" with expression '<code>0x0204</code>', CType: int */
  public static final int GL_GREATER = 0x204;
  /** Define "GL_DEPTH_FUNC" with expression '<code>0x0B74</code>', CType: int */
  public static final int GL_DEPTH_FUNC = 0xb74;
  /** Define "GL_ELEMENT_ARRAY_BUFFER" with expression '<code>0x8893</code>', CType: int */
  public static final int GL_ELEMENT_ARRAY_BUFFER = 0x8893;
  /** Define "GL_KEEP" with expression '<code>0x1E00</code>', CType: int */
  public static final int GL_KEEP = 0x1e00;
  /** Define "GL_LINEAR_MIPMAP_NEAREST" with expression '<code>0x2701</code>', CType: int */
  public static final int GL_LINEAR_MIPMAP_NEAREST = 0x2701;
  /** Define "GL_STENCIL_BACK_FAIL" with expression '<code>0x8801</code>', CType: int */
  public static final int GL_STENCIL_BACK_FAIL = 0x8801;
  /** Define "GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME" with expression '<code>0x8CD1</code>', CType: int */
  public static final int GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8cd1;
  /** Define "GL_MAX_RENDERBUFFER_SIZE" with expression '<code>0x84E8</code>', CType: int */
  public static final int GL_MAX_RENDERBUFFER_SIZE = 0x84e8;
  /** Define "GL_REPLACE" with expression '<code>0x1E01</code>', CType: int */
  public static final int GL_REPLACE = 0x1e01;
  /** Define "GL_STENCIL_BACK_PASS_DEPTH_PASS" with expression '<code>0x8803</code>', CType: int */
  public static final int GL_STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
  /** Define "GL_MEDIUM_FLOAT" with expression '<code>0x8DF1</code>', CType: int */
  public static final int GL_MEDIUM_FLOAT = 0x8df1;
  /** Define "GL_RENDERBUFFER_STENCIL_SIZE" with expression '<code>0x8D55</code>', CType: int */
  public static final int GL_RENDERBUFFER_STENCIL_SIZE = 0x8d55;
  /** Define "GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS" with expression '<code>0x8B4C</code>', CType: int */
  public static final int GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8b4c;
  /** Define "GL_FRAMEBUFFER" with expression '<code>0x8D40</code>', CType: int */
  public static final int GL_FRAMEBUFFER = 0x8d40;
  /** Define "GL_STENCIL_BACK_VALUE_MASK" with expression '<code>0x8CA4</code>', CType: int */
  public static final int GL_STENCIL_BACK_VALUE_MASK = 0x8ca4;
  /** Define "GL_TRIANGLES" with expression '<code>0x0004</code>', CType: int */
  public static final int GL_TRIANGLES = 0x4;
  /** Define "GL_TEXTURE_2D" with expression '<code>0x0DE1</code>', CType: int */
  public static final int GL_TEXTURE_2D = 0xde1;
  /** Define "GL_HIGH_FLOAT" with expression '<code>0x8DF2</code>', CType: int */
  public static final int GL_HIGH_FLOAT = 0x8df2;
  /** Define "GL_ARRAY_BUFFER" with expression '<code>0x8892</code>', CType: int */
  public static final int GL_ARRAY_BUFFER = 0x8892;
  /** Define "GL_STENCIL_BACK_FUNC" with expression '<code>0x8800</code>', CType: int */
  public static final int GL_STENCIL_BACK_FUNC = 0x8800;
  /** Define "GL_FIXED" with expression '<code>0x140C</code>', CType: int */
  public static final int GL_FIXED = 0x140c;
  /** Define "GL_DEPTH_BUFFER_BIT" with expression '<code>0x00000100</code>', CType: int */
  public static final int GL_DEPTH_BUFFER_BIT = 0x100;
  /** Define "GL_LINEAR" with expression '<code>0x2601</code>', CType: int */
  public static final int GL_LINEAR = 0x2601;
  /** Define "GL_ACTIVE_UNIFORM_MAX_LENGTH" with expression '<code>0x8B87</code>', CType: int */
  public static final int GL_ACTIVE_UNIFORM_MAX_LENGTH = 0x8b87;
  /** Define "GL_RGBA" with expression '<code>0x1908</code>', CType: int */
  public static final int GL_RGBA = 0x1908;
  /** Define "GL_NEAREST_MIPMAP_LINEAR" with expression '<code>0x2702</code>', CType: int */
  public static final int GL_NEAREST_MIPMAP_LINEAR = 0x2702;
  /** Define "GL_RENDERBUFFER_RED_SIZE" with expression '<code>0x8D50</code>', CType: int */
  public static final int GL_RENDERBUFFER_RED_SIZE = 0x8d50;
  /** Define "GL_SAMPLE_COVERAGE" with expression '<code>0x80A0</code>', CType: int */
  public static final int GL_SAMPLE_COVERAGE = 0x80a0;
  /** Define "GL_MAX_TEXTURE_SIZE" with expression '<code>0x0D33</code>', CType: int */
  public static final int GL_MAX_TEXTURE_SIZE = 0xd33;
  /** Define "GL_DYNAMIC_DRAW" with expression '<code>0x88E8</code>', CType: int */
  public static final int GL_DYNAMIC_DRAW = 0x88e8;
  /** Define "GL_OUT_OF_MEMORY" with expression '<code>0x0505</code>', CType: int */
  public static final int GL_OUT_OF_MEMORY = 0x505;
  /** Define "GL_EXTENSIONS" with expression '<code>0x1F03</code>', CType: int */
  public static final int GL_EXTENSIONS = 0x1f03;
  /** Define "GL_ACTIVE_TEXTURE" with expression '<code>0x84E0</code>', CType: int */
  public static final int GL_ACTIVE_TEXTURE = 0x84e0;
  /** Define "GL_COLOR_WRITEMASK" with expression '<code>0x0C23</code>', CType: int */
  public static final int GL_COLOR_WRITEMASK = 0xc23;
  /** Define "GL_NONE" with expression '<code>0</code>', CType: int */
  public static final int GL_NONE = 0x0;
  /** Define "GL_UNSIGNED_SHORT_5_6_5" with expression '<code>0x8363</code>', CType: int */
  public static final int GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
  /** Define "GL_RENDERBUFFER_WIDTH" with expression '<code>0x8D42</code>', CType: int */
  public static final int GL_RENDERBUFFER_WIDTH = 0x8d42;
  /** Define "GL_DEPTH_BITS" with expression '<code>0x0D56</code>', CType: int */
  public static final int GL_DEPTH_BITS = 0xd56;
  /** Define "GL_SRC_ALPHA_SATURATE" with expression '<code>0x0308</code>', CType: int */
  public static final int GL_SRC_ALPHA_SATURATE = 0x308;
  /** Define "GL_UNPACK_ALIGNMENT" with expression '<code>0x0CF5</code>', CType: int */
  public static final int GL_UNPACK_ALIGNMENT = 0xcf5;
  /** Define "GL_COMPILE_STATUS" with expression '<code>0x8B81</code>', CType: int */
  public static final int GL_COMPILE_STATUS = 0x8b81;
  /** Define "GL_ALPHA" with expression '<code>0x1906</code>', CType: int */
  public static final int GL_ALPHA = 0x1906;
  /** Define "GL_BYTE" with expression '<code>0x1400</code>', CType: int */
  public static final int GL_BYTE = 0x1400;
  /** Define "GL_NEVER" with expression '<code>0x0200</code>', CType: int */
  public static final int GL_NEVER = 0x200;
  /** Define "GL_DONT_CARE" with expression '<code>0x1100</code>', CType: int */
  public static final int GL_DONT_CARE = 0x1100;
  /** Define "GL_MIRRORED_REPEAT" with expression '<code>0x8370</code>', CType: int */
  public static final int GL_MIRRORED_REPEAT = 0x8370;
  /** Define "GL_FALSE" with expression '<code>0</code>', CType: int */
  public static final int GL_FALSE = 0x0;
  /** Define "GL_GENERATE_MIPMAP_HINT" with expression '<code>0x8192</code>', CType: int */
  public static final int GL_GENERATE_MIPMAP_HINT = 0x8192;
  /** Define "GL_RGB5_A1" with expression '<code>0x8057</code>', CType: int */
  public static final int GL_RGB5_A1 = 0x8057;
  /** Define "GL_SAMPLER_2D" with expression '<code>0x8B5E</code>', CType: int */
  public static final int GL_SAMPLER_2D = 0x8b5e;
  /** Define "GL_STENCIL_BACK_REF" with expression '<code>0x8CA3</code>', CType: int */
  public static final int GL_STENCIL_BACK_REF = 0x8ca3;
  /** Define "GL_BOOL" with expression '<code>0x8B56</code>', CType: int */
  public static final int GL_BOOL = 0x8b56;
  /** Define "GL_EQUAL" with expression '<code>0x0202</code>', CType: int */
  public static final int GL_EQUAL = 0x202;
  /** Define "GL_VERTEX_ATTRIB_ARRAY_POINTER" with expression '<code>0x8645</code>', CType: int */
  public static final int GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
  /** Define "GL_BUFFER_USAGE" with expression '<code>0x8765</code>', CType: int */
  public static final int GL_BUFFER_USAGE = 0x8765;
  /** Define "GL_BACK" with expression '<code>0x0405</code>', CType: int */
  public static final int GL_BACK = 0x405;
  /** Define "GL_TEXTURE_BINDING_CUBE_MAP" with expression '<code>0x8514</code>', CType: int */
  public static final int GL_TEXTURE_BINDING_CUBE_MAP = 0x8514;
  /** Define "KHRONOS_MAX_ENUM" with expression '<code>0x7FFFFFFF</code>', CType: int */
  public static final int KHRONOS_MAX_ENUM = 0x7fffffff;
  /** Define "GL_IMPLEMENTATION_COLOR_READ_TYPE" with expression '<code>0x8B9A</code>', CType: int */
  public static final int GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8b9a;
  /** Define "GL_ONE_MINUS_SRC_ALPHA" with expression '<code>0x0303</code>', CType: int */
  public static final int GL_ONE_MINUS_SRC_ALPHA = 0x303;
  /** Define "GL_SAMPLE_ALPHA_TO_COVERAGE" with expression '<code>0x809E</code>', CType: int */
  public static final int GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809e;
  /** Define "GL_ELEMENT_ARRAY_BUFFER_BINDING" with expression '<code>0x8895</code>', CType: int */
  public static final int GL_ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
  /** Define "GL_INT" with expression '<code>0x1404</code>', CType: int */
  public static final int GL_INT = 0x1404;
  /** Define "GL_VERTEX_ATTRIB_ARRAY_TYPE" with expression '<code>0x8625</code>', CType: int */
  public static final int GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
  /** Define "GL_FRAMEBUFFER_BINDING" with expression '<code>0x8CA6</code>', CType: int */
  public static final int GL_FRAMEBUFFER_BINDING = 0x8ca6;
  /** Define "GL_FLOAT_VEC2" with expression '<code>0x8B50</code>', CType: int */
  public static final int GL_FLOAT_VEC2 = 0x8b50;
  /** Define "GL_MEDIUM_INT" with expression '<code>0x8DF4</code>', CType: int */
  public static final int GL_MEDIUM_INT = 0x8df4;
  /** Define "GL_NUM_COMPRESSED_TEXTURE_FORMATS" with expression '<code>0x86A2</code>', CType: int */
  public static final int GL_NUM_COMPRESSED_TEXTURE_FORMATS = 0x86a2;
  /** Define "GL_TRIANGLE_STRIP" with expression '<code>0x0005</code>', CType: int */
  public static final int GL_TRIANGLE_STRIP = 0x5;
  /** Define "GL_FLOAT_VEC4" with expression '<code>0x8B52</code>', CType: int */
  public static final int GL_FLOAT_VEC4 = 0x8b52;
  /** Define "GL_FLOAT_VEC3" with expression '<code>0x8B51</code>', CType: int */
  public static final int GL_FLOAT_VEC3 = 0x8b51;
  /** Define "GL_LINE_LOOP" with expression '<code>0x0002</code>', CType: int */
  public static final int GL_LINE_LOOP = 0x2;
  /** Define "GL_DEPTH_WRITEMASK" with expression '<code>0x0B72</code>', CType: int */
  public static final int GL_DEPTH_WRITEMASK = 0xb72;
  /** Define "GL_MAX_VARYING_VECTORS" with expression '<code>0x8DFC</code>', CType: int */
  public static final int GL_MAX_VARYING_VECTORS = 0x8dfc;
  /** Define "GL_SAMPLE_BUFFERS" with expression '<code>0x80A8</code>', CType: int */
  public static final int GL_SAMPLE_BUFFERS = 0x80a8;
  /** Define "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT" with expression '<code>0x8CD6</code>', CType: int */
  public static final int GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8cd6;
  /** Define "GL_FUNC_REVERSE_SUBTRACT" with expression '<code>0x800B</code>', CType: int */
  public static final int GL_FUNC_REVERSE_SUBTRACT = 0x800b;
  /** Define "GL_STENCIL_BUFFER_BIT" with expression '<code>0x00000400</code>', CType: int */
  public static final int GL_STENCIL_BUFFER_BIT = 0x400;
  /** Define "GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE" with expression '<code>0x8CD3</code>', CType: int */
  public static final int GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8cd3;
  /** Define "GL_SCISSOR_BOX" with expression '<code>0x0C10</code>', CType: int */
  public static final int GL_SCISSOR_BOX = 0xc10;
  /** Define "GL_BUFFER_SIZE" with expression '<code>0x8764</code>', CType: int */
  public static final int GL_BUFFER_SIZE = 0x8764;
  /** Define "GL_VALIDATE_STATUS" with expression '<code>0x8B83</code>', CType: int */
  public static final int GL_VALIDATE_STATUS = 0x8b83;
  /** Define "GL_PACK_ALIGNMENT" with expression '<code>0x0D05</code>', CType: int */
  public static final int GL_PACK_ALIGNMENT = 0xd05;
  /** Define "GL_REPEAT" with expression '<code>0x2901</code>', CType: int */
  public static final int GL_REPEAT = 0x2901;
  /** Define "GL_TEXTURE_CUBE_MAP_POSITIVE_X" with expression '<code>0x8515</code>', CType: int */
  public static final int GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
  /** Define "GL_RENDERER" with expression '<code>0x1F01</code>', CType: int */
  public static final int GL_RENDERER = 0x1f01;
  /** Define "GL_TEXTURE_CUBE_MAP_POSITIVE_Y" with expression '<code>0x8517</code>', CType: int */
  public static final int GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
  /** Define "GL_TRIANGLE_FAN" with expression '<code>0x0006</code>', CType: int */
  public static final int GL_TRIANGLE_FAN = 0x6;
  /** Define "GL_TEXTURE_CUBE_MAP_POSITIVE_Z" with expression '<code>0x8519</code>', CType: int */
  public static final int GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
  /** Define "GL_STENCIL_CLEAR_VALUE" with expression '<code>0x0B91</code>', CType: int */
  public static final int GL_STENCIL_CLEAR_VALUE = 0xb91;
  /** Define "GL_RENDERBUFFER_DEPTH_SIZE" with expression '<code>0x8D54</code>', CType: int */
  public static final int GL_RENDERBUFFER_DEPTH_SIZE = 0x8d54;
  /** Define "GL_RENDERBUFFER_ALPHA_SIZE" with expression '<code>0x8D53</code>', CType: int */
  public static final int GL_RENDERBUFFER_ALPHA_SIZE = 0x8d53;
  /** Define "GL_FRONT_FACE" with expression '<code>0x0B46</code>', CType: int */
  public static final int GL_FRONT_FACE = 0xb46;
  /** Define "GL_POLYGON_OFFSET_UNITS" with expression '<code>0x2A00</code>', CType: int */
  public static final int GL_POLYGON_OFFSET_UNITS = 0x2a00;
  /** Define "GL_RGBA4" with expression '<code>0x8056</code>', CType: int */
  public static final int GL_RGBA4 = 0x8056;
  /** Define "GL_HIGH_INT" with expression '<code>0x8DF5</code>', CType: int */
  public static final int GL_HIGH_INT = 0x8df5;
  /** Define "KHRONOS_SUPPORT_FLOAT" with expression '<code>1</code>', CType: int */
  public static final int KHRONOS_SUPPORT_FLOAT = 0x1;
  /** Define "GL_TEXTURE0" with expression '<code>0x84C0</code>', CType: int */
  public static final int GL_TEXTURE0 = 0x84c0;
  /** Define "GL_STENCIL_INDEX8" with expression '<code>0x8D48</code>', CType: int */
  public static final int GL_STENCIL_INDEX8 = 0x8d48;
  /** Define "GL_ZERO" with expression '<code>0</code>', CType: int */
  public static final int GL_ZERO = 0x0;
  /** Define "GL_STENCIL_TEST" with expression '<code>0x0B90</code>', CType: int */
  public static final int GL_STENCIL_TEST = 0xb90;
  /** Define "GL_STREAM_DRAW" with expression '<code>0x88E0</code>', CType: int */
  public static final int GL_STREAM_DRAW = 0x88e0;
  /** Define "GL_DECR" with expression '<code>0x1E03</code>', CType: int */
  public static final int GL_DECR = 0x1e03;
  /** Define "GL_TEXTURE4" with expression '<code>0x84C4</code>', CType: int */
  public static final int GL_TEXTURE4 = 0x84c4;
  /** Define "GL_BOOL_VEC4" with expression '<code>0x8B59</code>', CType: int */
  public static final int GL_BOOL_VEC4 = 0x8b59;
  /** Define "GL_RENDERBUFFER_INTERNAL_FORMAT" with expression '<code>0x8D44</code>', CType: int */
  public static final int GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8d44;
  /** Define "GL_TEXTURE3" with expression '<code>0x84C3</code>', CType: int */
  public static final int GL_TEXTURE3 = 0x84c3;
  /** Define "GL_BOOL_VEC3" with expression '<code>0x8B58</code>', CType: int */
  public static final int GL_BOOL_VEC3 = 0x8b58;
  /** Define "GL_TEXTURE2" with expression '<code>0x84C2</code>', CType: int */
  public static final int GL_TEXTURE2 = 0x84c2;
  /** Define "GL_BOOL_VEC2" with expression '<code>0x8B57</code>', CType: int */
  public static final int GL_BOOL_VEC2 = 0x8b57;
  /** Define "GL_TEXTURE1" with expression '<code>0x84C1</code>', CType: int */
  public static final int GL_TEXTURE1 = 0x84c1;
  /** Define "GL_TEXTURE8" with expression '<code>0x84C8</code>', CType: int */
  public static final int GL_TEXTURE8 = 0x84c8;
  /** Define "GL_TEXTURE7" with expression '<code>0x84C7</code>', CType: int */
  public static final int GL_TEXTURE7 = 0x84c7;
  /** Define "GL_STATIC_DRAW" with expression '<code>0x88E4</code>', CType: int */
  public static final int GL_STATIC_DRAW = 0x88e4;
  /** Define "GL_TEXTURE6" with expression '<code>0x84C6</code>', CType: int */
  public static final int GL_TEXTURE6 = 0x84c6;
  /** Define "GL_TEXTURE5" with expression '<code>0x84C5</code>', CType: int */
  public static final int GL_TEXTURE5 = 0x84c5;
  /** Define "GL_FUNC_ADD" with expression '<code>0x8006</code>', CType: int */
  public static final int GL_FUNC_ADD = 0x8006;
  /** Define "GL_UNSIGNED_SHORT" with expression '<code>0x1403</code>', CType: int */
  public static final int GL_UNSIGNED_SHORT = 0x1403;
  /** Define "GL_TEXTURE9" with expression '<code>0x84C9</code>', CType: int */
  public static final int GL_TEXTURE9 = 0x84c9;
  /** Define "GL_POINTS" with expression '<code>0x0000</code>', CType: int */
  public static final int GL_POINTS = 0x0;
  /** Define "GL_CLAMP_TO_EDGE" with expression '<code>0x812F</code>', CType: int */
  public static final int GL_CLAMP_TO_EDGE = 0x812f;
  /** Define "GL_LINES" with expression '<code>0x0001</code>', CType: int */
  public static final int GL_LINES = 0x1;
  /** Define "GL_TEXTURE20" with expression '<code>0x84D4</code>', CType: int */
  public static final int GL_TEXTURE20 = 0x84d4;
  /** Define "KHRONOS_SUPPORT_INT64" with expression '<code>1</code>', CType: int */
  public static final int KHRONOS_SUPPORT_INT64 = 0x1;
  /** Define "GL_MAX_VIEWPORT_DIMS" with expression '<code>0x0D3A</code>', CType: int */
  public static final int GL_MAX_VIEWPORT_DIMS = 0xd3a;
  /** Define "GL_DECR_WRAP" with expression '<code>0x8508</code>', CType: int */
  public static final int GL_DECR_WRAP = 0x8508;
  /** Define "GL_COLOR_ATTACHMENT0" with expression '<code>0x8CE0</code>', CType: int */
  public static final int GL_COLOR_ATTACHMENT0 = 0x8ce0;
  /** Define "GL_SHADER_TYPE" with expression '<code>0x8B4F</code>', CType: int */
  public static final int GL_SHADER_TYPE = 0x8b4f;
  /** Define "GL_ALPHA_BITS" with expression '<code>0x0D55</code>', CType: int */
  public static final int GL_ALPHA_BITS = 0xd55;
  /** Define "GL_FLOAT_MAT4" with expression '<code>0x8B5C</code>', CType: int */
  public static final int GL_FLOAT_MAT4 = 0x8b5c;
  /** Define "GL_FLOAT_MAT3" with expression '<code>0x8B5B</code>', CType: int */
  public static final int GL_FLOAT_MAT3 = 0x8b5b;
  /** Define "GL_ONE_MINUS_CONSTANT_COLOR" with expression '<code>0x8002</code>', CType: int */
  public static final int GL_ONE_MINUS_CONSTANT_COLOR = 0x8002;
  /** Define "GL_FLOAT_MAT2" with expression '<code>0x8B5A</code>', CType: int */
  public static final int GL_FLOAT_MAT2 = 0x8b5a;
  /** Define "GL_BLEND_DST_ALPHA" with expression '<code>0x80CA</code>', CType: int */
  public static final int GL_BLEND_DST_ALPHA = 0x80ca;
  /** Define "GL_TEXTURE19" with expression '<code>0x84D3</code>', CType: int */
  public static final int GL_TEXTURE19 = 0x84d3;
  /** Define "GL_ACTIVE_ATTRIBUTES" with expression '<code>0x8B89</code>', CType: int */
  public static final int GL_ACTIVE_ATTRIBUTES = 0x8b89;
  /** Define "GL_TEXTURE18" with expression '<code>0x84D2</code>', CType: int */
  public static final int GL_TEXTURE18 = 0x84d2;
  /** Define "GL_TEXTURE17" with expression '<code>0x84D1</code>', CType: int */
  public static final int GL_TEXTURE17 = 0x84d1;
  /** Define "GL_TEXTURE16" with expression '<code>0x84D0</code>', CType: int */
  public static final int GL_TEXTURE16 = 0x84d0;
  /** Define "GL_TEXTURE15" with expression '<code>0x84CF</code>', CType: int */
  public static final int GL_TEXTURE15 = 0x84cf;
  /** Define "GL_TEXTURE14" with expression '<code>0x84CE</code>', CType: int */
  public static final int GL_TEXTURE14 = 0x84ce;
  /** Define "GL_MAX_TEXTURE_IMAGE_UNITS" with expression '<code>0x8872</code>', CType: int */
  public static final int GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;
  /** Define "GL_TEXTURE13" with expression '<code>0x84CD</code>', CType: int */
  public static final int GL_TEXTURE13 = 0x84cd;
  /** Define "GL_GLES_PROTOTYPES" with expression '<code>1</code>', CType: int */
  public static final int GL_GLES_PROTOTYPES = 0x1;
  /** Define "GL_TEXTURE12" with expression '<code>0x84CC</code>', CType: int */
  public static final int GL_TEXTURE12 = 0x84cc;
  /** Define "GL_BLEND_SRC_ALPHA" with expression '<code>0x80CB</code>', CType: int */
  public static final int GL_BLEND_SRC_ALPHA = 0x80cb;
  /** Define "GL_TEXTURE11" with expression '<code>0x84CB</code>', CType: int */
  public static final int GL_TEXTURE11 = 0x84cb;
  /** Define "GL_MAX_VERTEX_ATTRIBS" with expression '<code>0x8869</code>', CType: int */
  public static final int GL_MAX_VERTEX_ATTRIBS = 0x8869;
  /** Define "GL_TEXTURE10" with expression '<code>0x84CA</code>', CType: int */
  public static final int GL_TEXTURE10 = 0x84ca;
  /** Define "GL_LINEAR_MIPMAP_LINEAR" with expression '<code>0x2703</code>', CType: int */
  public static final int GL_LINEAR_MIPMAP_LINEAR = 0x2703;
  /** Define "GL_TEXTURE31" with expression '<code>0x84DF</code>', CType: int */
  public static final int GL_TEXTURE31 = 0x84df;
  /** Define "GL_COLOR_CLEAR_VALUE" with expression '<code>0x0C22</code>', CType: int */
  public static final int GL_COLOR_CLEAR_VALUE = 0xc22;
  /** Define "GL_TEXTURE30" with expression '<code>0x84DE</code>', CType: int */
  public static final int GL_TEXTURE30 = 0x84de;
  /** Define "GL_BLEND_EQUATION_RGB" with expression '<code>0x8009</code>', CType: int */
  public static final int GL_BLEND_EQUATION_RGB = 0x8009;
  /** Define "GL_TEXTURE_CUBE_MAP_NEGATIVE_X" with expression '<code>0x8516</code>', CType: int */
  public static final int GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
  /** Define "GL_TEXTURE_CUBE_MAP_NEGATIVE_Z" with expression '<code>0x851A</code>', CType: int */
  public static final int GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;
  /** Define "GL_INCR_WRAP" with expression '<code>0x8507</code>', CType: int */
  public static final int GL_INCR_WRAP = 0x8507;
  /** Define "GL_TEXTURE_CUBE_MAP_NEGATIVE_Y" with expression '<code>0x8518</code>', CType: int */
  public static final int GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
  /** Define "GL_UNSIGNED_SHORT_4_4_4_4" with expression '<code>0x8033</code>', CType: int */
  public static final int GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
  /** Define "GL_VERTEX_ATTRIB_ARRAY_STRIDE" with expression '<code>0x8624</code>', CType: int */
  public static final int GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
  /** Define "GL_NEAREST_MIPMAP_NEAREST" with expression '<code>0x2700</code>', CType: int */
  public static final int GL_NEAREST_MIPMAP_NEAREST = 0x2700;
  /** Define "GL_CONSTANT_ALPHA" with expression '<code>0x8003</code>', CType: int */
  public static final int GL_CONSTANT_ALPHA = 0x8003;
  /** Define "GL_STENCIL_PASS_DEPTH_FAIL" with expression '<code>0x0B95</code>', CType: int */
  public static final int GL_STENCIL_PASS_DEPTH_FAIL = 0xb95;
  /** Define "GL_SAMPLE_COVERAGE_INVERT" with expression '<code>0x80AB</code>', CType: int */
  public static final int GL_SAMPLE_COVERAGE_INVERT = 0x80ab;
  /** Define "GL_TEXTURE29" with expression '<code>0x84DD</code>', CType: int */
  public static final int GL_TEXTURE29 = 0x84dd;
  /** Define "GL_ONE_MINUS_CONSTANT_ALPHA" with expression '<code>0x8004</code>', CType: int */
  public static final int GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004;
  /** Define "GL_TEXTURE28" with expression '<code>0x84DC</code>', CType: int */
  public static final int GL_TEXTURE28 = 0x84dc;
  /** Define "GL_TEXTURE27" with expression '<code>0x84DB</code>', CType: int */
  public static final int GL_TEXTURE27 = 0x84db;
  /** Define "GL_TEXTURE26" with expression '<code>0x84DA</code>', CType: int */
  public static final int GL_TEXTURE26 = 0x84da;
  /** Define "GL_TEXTURE25" with expression '<code>0x84D9</code>', CType: int */
  public static final int GL_TEXTURE25 = 0x84d9;
  /** Define "GL_CURRENT_PROGRAM" with expression '<code>0x8B8D</code>', CType: int */
  public static final int GL_CURRENT_PROGRAM = 0x8b8d;
  /** Define "GL_TEXTURE24" with expression '<code>0x84D8</code>', CType: int */
  public static final int GL_TEXTURE24 = 0x84d8;
  /** Define "GL_INT_VEC4" with expression '<code>0x8B55</code>', CType: int */
  public static final int GL_INT_VEC4 = 0x8b55;
  /** Define "GL_TEXTURE23" with expression '<code>0x84D7</code>', CType: int */
  public static final int GL_TEXTURE23 = 0x84d7;
  /** Define "GL_TEXTURE22" with expression '<code>0x84D6</code>', CType: int */
  public static final int GL_TEXTURE22 = 0x84d6;
  /** Define "GL_INT_VEC2" with expression '<code>0x8B53</code>', CType: int */
  public static final int GL_INT_VEC2 = 0x8b53;
  /** Define "GL_TEXTURE21" with expression '<code>0x84D5</code>', CType: int */
  public static final int GL_TEXTURE21 = 0x84d5;
  /** Define "GL_INT_VEC3" with expression '<code>0x8B54</code>', CType: int */
  public static final int GL_INT_VEC3 = 0x8b54;
  /** Define "GL_DEPTH_RANGE" with expression '<code>0x0B70</code>', CType: int */
  public static final int GL_DEPTH_RANGE = 0xb70;
  /** Define "GL_BLUE_BITS" with expression '<code>0x0D54</code>', CType: int */
  public static final int GL_BLUE_BITS = 0xd54;
  /** Define "GL_FLOAT" with expression '<code>0x1406</code>', CType: int */
  public static final int GL_FLOAT = 0x1406;
  /** Define "GL_BLEND_EQUATION" with expression '<code>0x8009</code>', CType: int */
  public static final int GL_BLEND_EQUATION = 0x8009;
  /** Define "GL_RENDERBUFFER_HEIGHT" with expression '<code>0x8D43</code>', CType: int */
  public static final int GL_RENDERBUFFER_HEIGHT = 0x8d43;
  /** Define "GL_INCR" with expression '<code>0x1E02</code>', CType: int */
  public static final int GL_INCR = 0x1e02;
  /** Define "GL_POLYGON_OFFSET_FILL" with expression '<code>0x8037</code>', CType: int */
  public static final int GL_POLYGON_OFFSET_FILL = 0x8037;
  /** Define "GL_STENCIL_ATTACHMENT" with expression '<code>0x8D20</code>', CType: int */
  public static final int GL_STENCIL_ATTACHMENT = 0x8d20;
  /** Define "GL_INVALID_VALUE" with expression '<code>0x0501</code>', CType: int */
  public static final int GL_INVALID_VALUE = 0x501;
  /** Define "GL_FUNC_SUBTRACT" with expression '<code>0x800A</code>', CType: int */
  public static final int GL_FUNC_SUBTRACT = 0x800a;
  /** Define "GL_FRAMEBUFFER_UNSUPPORTED" with expression '<code>0x8CDD</code>', CType: int */
  public static final int GL_FRAMEBUFFER_UNSUPPORTED = 0x8cdd;
  /** Define "GL_GEQUAL" with expression '<code>0x0206</code>', CType: int */
  public static final int GL_GEQUAL = 0x206;
  /** Define "GL_TEXTURE_MIN_FILTER" with expression '<code>0x2801</code>', CType: int */
  public static final int GL_TEXTURE_MIN_FILTER = 0x2801;
  /** Define "GL_ES_VERSION_2_0" with expression '<code>1</code>', CType: int */
  public static final int GL_ES_VERSION_2_0 = 0x1;
  /** Define "GL_NICEST" with expression '<code>0x1102</code>', CType: int */
  public static final int GL_NICEST = 0x1102;
  /** Define "GL_STENCIL_FUNC" with expression '<code>0x0B92</code>', CType: int */
  public static final int GL_STENCIL_FUNC = 0xb92;
  /** Define "GL_UNSIGNED_BYTE" with expression '<code>0x1401</code>', CType: int */
  public static final int GL_UNSIGNED_BYTE = 0x1401;
  /** Define "GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE" with expression '<code>0x8CD0</code>', CType: int */
  public static final int GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8cd0;
  /** Define "GL_SHADING_LANGUAGE_VERSION" with expression '<code>0x8B8C</code>', CType: int */
  public static final int GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
  /** Define "GL_VERSION" with expression '<code>0x1F02</code>', CType: int */
  public static final int GL_VERSION = 0x1f02;
  /** Define "GL_CONSTANT_COLOR" with expression '<code>0x8001</code>', CType: int */
  public static final int GL_CONSTANT_COLOR = 0x8001;
  /** Define "GL_IMPLEMENTATION_COLOR_READ_FORMAT" with expression '<code>0x8B9B</code>', CType: int */
  public static final int GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8b9b;
  /** Define "GL_TEXTURE_MAG_FILTER" with expression '<code>0x2800</code>', CType: int */
  public static final int GL_TEXTURE_MAG_FILTER = 0x2800;
  /** Define "GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING" with expression '<code>0x889F</code>', CType: int */
  public static final int GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889f;
  /** Define "GL_DST_ALPHA" with expression '<code>0x0304</code>', CType: int */
  public static final int GL_DST_ALPHA = 0x304;
  /** Define "GL_STENCIL_BACK_PASS_DEPTH_FAIL" with expression '<code>0x8802</code>', CType: int */
  public static final int GL_STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
  /** Define "GL_LINK_STATUS" with expression '<code>0x8B82</code>', CType: int */
  public static final int GL_LINK_STATUS = 0x8b82;
  /** Define "GL_COMPRESSED_TEXTURE_FORMATS" with expression '<code>0x86A3</code>', CType: int */
  public static final int GL_COMPRESSED_TEXTURE_FORMATS = 0x86a3;
  /** Define "GL_ATTACHED_SHADERS" with expression '<code>0x8B85</code>', CType: int */
  public static final int GL_ATTACHED_SHADERS = 0x8b85;
  /** Define "GL_RENDERBUFFER_BLUE_SIZE" with expression '<code>0x8D52</code>', CType: int */
  public static final int GL_RENDERBUFFER_BLUE_SIZE = 0x8d52;
  /** Define "GL_LOW_INT" with expression '<code>0x8DF3</code>', CType: int */
  public static final int GL_LOW_INT = 0x8df3;
  /** Define "__gles2_gl2_h_" with expression '<code>1</code>', CType: int */
  public static final int __gles2_gl2_h_ = 0x1;
  /** Define "GL_DITHER" with expression '<code>0x0BD0</code>', CType: int */
  public static final int GL_DITHER = 0xbd0;
  /** Define "GL_RGB565" with expression '<code>0x8D62</code>', CType: int */
  public static final int GL_RGB565 = 0x8d62;
  /** Define "GL_VERTEX_ATTRIB_ARRAY_SIZE" with expression '<code>0x8623</code>', CType: int */
  public static final int GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
  /** Define "GL_SAMPLES" with expression '<code>0x80A9</code>', CType: int */
  public static final int GL_SAMPLES = 0x80a9;
  /** Define "GL_SRC_COLOR" with expression '<code>0x0300</code>', CType: int */
  public static final int GL_SRC_COLOR = 0x300;
  /** Define "GL_LINE_WIDTH" with expression '<code>0x0B21</code>', CType: int */
  public static final int GL_LINE_WIDTH = 0xb21;
  /** Define "GL_STENCIL_FAIL" with expression '<code>0x0B94</code>', CType: int */
  public static final int GL_STENCIL_FAIL = 0xb94;
  /** Define "GL_STENCIL_WRITEMASK" with expression '<code>0x0B98</code>', CType: int */
  public static final int GL_STENCIL_WRITEMASK = 0xb98;
  /** Define "GL_FRONT" with expression '<code>0x0404</code>', CType: int */
  public static final int GL_FRONT = 0x404;
  /** Define "GL_TEXTURE_BINDING_2D" with expression '<code>0x8069</code>', CType: int */
  public static final int GL_TEXTURE_BINDING_2D = 0x8069;
  /** Define "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS" with expression '<code>0x8B4D</code>', CType: int */
  public static final int GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8b4d;
  /** Define "GL_NOTEQUAL" with expression '<code>0x0205</code>', CType: int */
  public static final int GL_NOTEQUAL = 0x205;
  /** Define "GL_SUBPIXEL_BITS" with expression '<code>0x0D50</code>', CType: int */
  public static final int GL_SUBPIXEL_BITS = 0xd50;
  /** Define "GL_RGB" with expression '<code>0x1907</code>', CType: int */
  public static final int GL_RGB = 0x1907;
  /** Define "GL_VERTEX_ATTRIB_ARRAY_ENABLED" with expression '<code>0x8622</code>', CType: int */
  public static final int GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
  /** Define "GL_SHADER_SOURCE_LENGTH" with expression '<code>0x8B88</code>', CType: int */
  public static final int GL_SHADER_SOURCE_LENGTH = 0x8b88;
  /** Define "GL_STENCIL_BITS" with expression '<code>0x0D57</code>', CType: int */
  public static final int GL_STENCIL_BITS = 0xd57;
  /** Define "GL_CULL_FACE_MODE" with expression '<code>0x0B45</code>', CType: int */
  public static final int GL_CULL_FACE_MODE = 0xb45;
  /** Define "GL_RENDERBUFFER_GREEN_SIZE" with expression '<code>0x8D51</code>', CType: int */
  public static final int GL_RENDERBUFFER_GREEN_SIZE = 0x8d51;
  /** Define "GL_UNSIGNED_SHORT_5_5_5_1" with expression '<code>0x8034</code>', CType: int */
  public static final int GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
  /** Define "GL_SAMPLER_CUBE" with expression '<code>0x8B60</code>', CType: int */
  public static final int GL_SAMPLER_CUBE = 0x8b60;
  /** Define "GL_FASTEST" with expression '<code>0x1101</code>', CType: int */
  public static final int GL_FASTEST = 0x1101;
  /** Define "GL_BLEND_DST_RGB" with expression '<code>0x80C8</code>', CType: int */
  public static final int GL_BLEND_DST_RGB = 0x80c8;
  /** Define "GL_VERTEX_ATTRIB_ARRAY_NORMALIZED" with expression '<code>0x886A</code>', CType: int */
  public static final int GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886a;
  /** Define "GL_BLEND" with expression '<code>0x0BE2</code>', CType: int */
  public static final int GL_BLEND = 0xbe2;
  /** Define "GL_SRC_ALPHA" with expression '<code>0x0302</code>', CType: int */
  public static final int GL_SRC_ALPHA = 0x302;
  /** Define "GL_DEPTH_COMPONENT16" with expression '<code>0x81A5</code>', CType: int */
  public static final int GL_DEPTH_COMPONENT16 = 0x81a5;

  /** Interface to C language function: <br> <code>void glActiveTexture(GLenum texture)</code><br>   */
  public static native void glActiveTexture(int texture);

  /** Interface to C language function: <br> <code>void glAttachShader(GLuint program, GLuint shader)</code><br>   */
  public static native void glAttachShader(int program, int shader);

  /** Interface to C language function: <br> <code>void glBindAttribLocation(GLuint program, GLuint index, const GLchar *  name)</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static void glBindAttribLocation(int program, int index, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    glBindAttribLocation1(program, index, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct);
  }

  /** Entry point to C language function: <code>void glBindAttribLocation(GLuint program, GLuint index, const GLchar *  name)</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native void glBindAttribLocation1(int program, int index, Object name, int name_byte_offset, boolean name_is_direct);

  /** Interface to C language function: <br> <code>void glBindAttribLocation(GLuint program, GLuint index, const GLchar *  name)</code><br>   */
  public static void glBindAttribLocation(int program, int index, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new RuntimeException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    glBindAttribLocation1(program, index, name, name_offset, false);
  }

  /** Interface to C language function: <br> <code>void glBindBuffer(GLenum target, GLuint buffer)</code><br>   */
  public static native void glBindBuffer(int target, int buffer);

  /** Interface to C language function: <br> <code>void glBindFramebuffer(GLenum target, GLuint framebuffer)</code><br>   */
  public static native void glBindFramebuffer(int target, int framebuffer);

  /** Interface to C language function: <br> <code>void glBindRenderbuffer(GLenum target, GLuint renderbuffer)</code><br>   */
  public static native void glBindRenderbuffer(int target, int renderbuffer);

  /** Interface to C language function: <br> <code>void glBindTexture(GLenum target, GLuint texture)</code><br>   */
  public static native void glBindTexture(int target, int texture);

  /** Interface to C language function: <br> <code>void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)</code><br>   */
  public static native void glBlendColor(float red, float green, float blue, float alpha);

  /** Interface to C language function: <br> <code>void glBlendEquation(GLenum mode)</code><br>   */
  public static native void glBlendEquation(int mode);

  /** Interface to C language function: <br> <code>void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)</code><br>   */
  public static native void glBlendEquationSeparate(int modeRGB, int modeAlpha);

  /** Interface to C language function: <br> <code>void glBlendFunc(GLenum sfactor, GLenum dfactor)</code><br>   */
  public static native void glBlendFunc(int sfactor, int dfactor);

  /** Interface to C language function: <br> <code>void glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)</code><br>   */
  public static native void glBlendFuncSeparate(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha);

  /** Interface to C language function: <br> <code>void glBufferData(GLenum target, GLsizeiptr size, const void *  data, GLenum usage)</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public static void glBufferData(int target, int size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    glBufferData1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage);
  }

  /** Entry point to C language function: <code>void glBufferData(GLenum target, GLsizeiptr size, const void *  data, GLenum usage)</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glBufferData1(int target, int size, Object data, int data_byte_offset, boolean data_is_direct, int usage);

  /** Interface to C language function: <br> <code>void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public static void glBufferSubData(int target, int offset, int size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    glBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct);
  }

  /** Entry point to C language function: <code>void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glBufferSubData1(int target, int offset, int size, Object data, int data_byte_offset, boolean data_is_direct);

  /** Interface to C language function: <br> <code>GLenum glCheckFramebufferStatus(GLenum target)</code><br>   */
  public static native int glCheckFramebufferStatus(int target);

  /** Interface to C language function: <br> <code>void glClear(GLbitfield mask)</code><br>   */
  public static native void glClear(int mask);

  /** Interface to C language function: <br> <code>void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)</code><br>   */
  public static native void glClearColor(float red, float green, float blue, float alpha);

  /** Interface to C language function: <br> <code>void glClearDepthf(GLfloat d)</code><br>   */
  public static native void glClearDepthf(float d);

  /** Interface to C language function: <br> <code>void glClearStencil(GLint s)</code><br>   */
  public static native void glClearStencil(int s);

  /** Interface to C language function: <br> <code>void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)</code><br>   */
  public static native void glColorMask(byte red, byte green, byte blue, byte alpha);

  /** Interface to C language function: <br> <code>void glCompileShader(GLuint shader)</code><br>   */
  public static native void glCompileShader(int shader);

  /** Interface to C language function: <br> <code>void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public static void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct);
  }

  /** Entry point to C language function: <code>void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct);

  /** Interface to C language function: <br> <code>void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public static void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct);
  }

  /** Entry point to C language function: <code>void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct);

  /** Interface to C language function: <br> <code>void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)</code><br>   */
  public static native void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border);

  /** Interface to C language function: <br> <code>void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)</code><br>   */
  public static native void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height);

  /** Interface to C language function: <br> <code>GLuint glCreateProgram()</code><br>   */
  public static native int glCreateProgram();

  /** Interface to C language function: <br> <code>GLuint glCreateShader(GLenum type)</code><br>   */
  public static native int glCreateShader(int type);

  /** Interface to C language function: <br> <code>void glCullFace(GLenum mode)</code><br>   */
  public static native void glCullFace(int mode);

  /** Interface to C language function: <br> <code>void glDeleteBuffers(GLsizei n, const GLuint *  buffers)</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glDeleteBuffers(int n, IntBuffer buffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    glDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct);
  }

  /** Entry point to C language function: <code>void glDeleteBuffers(GLsizei n, const GLuint *  buffers)</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct);

  /** Interface to C language function: <br> <code>void glDeleteBuffers(GLsizei n, const GLuint *  buffers)</code><br>   */
  public static void glDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new RuntimeException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    glDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false);
  }

  /** Interface to C language function: <br> <code>void glDeleteFramebuffers(GLsizei n, const GLuint *  framebuffers)</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glDeleteFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    glDeleteFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct);
  }

  /** Entry point to C language function: <code>void glDeleteFramebuffers(GLsizei n, const GLuint *  framebuffers)</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glDeleteFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct);

  /** Interface to C language function: <br> <code>void glDeleteFramebuffers(GLsizei n, const GLuint *  framebuffers)</code><br>   */
  public static void glDeleteFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new RuntimeException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    glDeleteFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false);
  }

  /** Interface to C language function: <br> <code>void glDeleteProgram(GLuint program)</code><br>   */
  public static native void glDeleteProgram(int program);

  /** Interface to C language function: <br> <code>void glDeleteRenderbuffers(GLsizei n, const GLuint *  renderbuffers)</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glDeleteRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    glDeleteRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct);
  }

  /** Entry point to C language function: <code>void glDeleteRenderbuffers(GLsizei n, const GLuint *  renderbuffers)</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glDeleteRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct);

  /** Interface to C language function: <br> <code>void glDeleteRenderbuffers(GLsizei n, const GLuint *  renderbuffers)</code><br>   */
  public static void glDeleteRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new RuntimeException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    glDeleteRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false);
  }

  /** Interface to C language function: <br> <code>void glDeleteShader(GLuint shader)</code><br>   */
  public static native void glDeleteShader(int shader);

  /** Interface to C language function: <br> <code>void glDeleteTextures(GLsizei n, const GLuint *  textures)</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glDeleteTextures(int n, IntBuffer textures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    glDeleteTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct);
  }

  /** Entry point to C language function: <code>void glDeleteTextures(GLsizei n, const GLuint *  textures)</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glDeleteTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct);

  /** Interface to C language function: <br> <code>void glDeleteTextures(GLsizei n, const GLuint *  textures)</code><br>   */
  public static void glDeleteTextures(int n, int[] textures, int textures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new RuntimeException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    glDeleteTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false);
  }

  /** Interface to C language function: <br> <code>void glDepthFunc(GLenum func)</code><br>   */
  public static native void glDepthFunc(int func);

  /** Interface to C language function: <br> <code>void glDepthMask(GLboolean flag)</code><br>   */
  public static native void glDepthMask(byte flag);

  /** Interface to C language function: <br> <code>void glDepthRangef(GLfloat n, GLfloat f)</code><br>   */
  public static native void glDepthRangef(float n, float f);

  /** Interface to C language function: <br> <code>void glDetachShader(GLuint program, GLuint shader)</code><br>   */
  public static native void glDetachShader(int program, int shader);

  /** Interface to C language function: <br> <code>void glDisable(GLenum cap)</code><br>   */
  public static native void glDisable(int cap);

  /** Interface to C language function: <br> <code>void glDisableVertexAttribArray(GLuint index)</code><br>   */
  public static native void glDisableVertexAttribArray(int index);

  /** Interface to C language function: <br> <code>void glDrawArrays(GLenum mode, GLint first, GLsizei count)</code><br>   */
  public static native void glDrawArrays(int mode, int first, int count);

  /** Interface to C language function: <br> <code>void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *  indices)</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public static void glDrawElements(int mode, int count, int type, Buffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    glDrawElements1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct);
  }

  /** Entry point to C language function: <code>void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *  indices)</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glDrawElements1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct);

  /** Interface to C language function: <br> <code>void glEnable(GLenum cap)</code><br>   */
  public static native void glEnable(int cap);

  /** Interface to C language function: <br> <code>void glEnableVertexAttribArray(GLuint index)</code><br>   */
  public static native void glEnableVertexAttribArray(int index);

  /** Interface to C language function: <br> <code>void glFinish()</code><br>   */
  public static native void glFinish();

  /** Interface to C language function: <br> <code>void glFlush()</code><br>   */
  public static native void glFlush();

  /** Interface to C language function: <br> <code>void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)</code><br>   */
  public static native void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer);

  /** Interface to C language function: <br> <code>void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)</code><br>   */
  public static native void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level);

  /** Interface to C language function: <br> <code>void glFrontFace(GLenum mode)</code><br>   */
  public static native void glFrontFace(int mode);

  /** Interface to C language function: <br> <code>void glGenBuffers(GLsizei n, GLuint *  buffers)</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGenBuffers(int n, IntBuffer buffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    glGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct);
  }

  /** Entry point to C language function: <code>void glGenBuffers(GLsizei n, GLuint *  buffers)</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct);

  /** Interface to C language function: <br> <code>void glGenBuffers(GLsizei n, GLuint *  buffers)</code><br>   */
  public static void glGenBuffers(int n, int[] buffers, int buffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new RuntimeException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    glGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGenerateMipmap(GLenum target)</code><br>   */
  public static native void glGenerateMipmap(int target);

  /** Interface to C language function: <br> <code>void glGenFramebuffers(GLsizei n, GLuint *  framebuffers)</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGenFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    glGenFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct);
  }

  /** Entry point to C language function: <code>void glGenFramebuffers(GLsizei n, GLuint *  framebuffers)</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGenFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct);

  /** Interface to C language function: <br> <code>void glGenFramebuffers(GLsizei n, GLuint *  framebuffers)</code><br>   */
  public static void glGenFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new RuntimeException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    glGenFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGenRenderbuffers(GLsizei n, GLuint *  renderbuffers)</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGenRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    glGenRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct);
  }

  /** Entry point to C language function: <code>void glGenRenderbuffers(GLsizei n, GLuint *  renderbuffers)</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGenRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct);

  /** Interface to C language function: <br> <code>void glGenRenderbuffers(GLsizei n, GLuint *  renderbuffers)</code><br>   */
  public static void glGenRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new RuntimeException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    glGenRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGenTextures(GLsizei n, GLuint *  textures)</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGenTextures(int n, IntBuffer textures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    glGenTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct);
  }

  /** Entry point to C language function: <code>void glGenTextures(GLsizei n, GLuint *  textures)</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGenTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct);

  /** Interface to C language function: <br> <code>void glGenTextures(GLsizei n, GLuint *  textures)</code><br>   */
  public static void glGenTextures(int n, int[] textures, int textures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new RuntimeException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    glGenTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static void glGetActiveAttrib(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    glGetActiveAttrib1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct);
  }

  /** Entry point to C language function: <code>void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native void glGetActiveAttrib1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct);

  /** Interface to C language function: <br> <code>void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name)</code><br>   */
  public static void glGetActiveAttrib(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new RuntimeException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new RuntimeException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new RuntimeException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new RuntimeException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    glGetActiveAttrib1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static void glGetActiveUniform(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    glGetActiveUniform1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct);
  }

  /** Entry point to C language function: <code>void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native void glGetActiveUniform1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct);

  /** Interface to C language function: <br> <code>void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name)</code><br>   */
  public static void glGetActiveUniform(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new RuntimeException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new RuntimeException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new RuntimeException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new RuntimeException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    glGetActiveUniform1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders)</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetAttachedShaders(int program, int maxCount, IntBuffer count, IntBuffer shaders)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    glGetAttachedShaders1(program, maxCount, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct);
  }

  /** Entry point to C language function: <code>void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders)</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetAttachedShaders1(int program, int maxCount, Object count, int count_byte_offset, boolean count_is_direct, Object shaders, int shaders_byte_offset, boolean shaders_is_direct);

  /** Interface to C language function: <br> <code>void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders)</code><br>   */
  public static void glGetAttachedShaders(int program, int maxCount, int[] count, int count_offset, int[] shaders, int shaders_offset)  {

    if(count != null && count.length <= count_offset)
      throw new RuntimeException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(shaders != null && shaders.length <= shaders_offset)
      throw new RuntimeException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    glGetAttachedShaders1(program, maxCount, count, Buffers.SIZEOF_INT * count_offset, false, shaders, Buffers.SIZEOF_INT * shaders_offset, false);
  }

  /** Interface to C language function: <br> <code>GLint glGetAttribLocation(GLuint program, const GLchar *  name)</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static int glGetAttribLocation(int program, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
        return glGetAttribLocation1(program, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct);
  }

  /** Entry point to C language function: <code>GLint glGetAttribLocation(GLuint program, const GLchar *  name)</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native int glGetAttribLocation1(int program, Object name, int name_byte_offset, boolean name_is_direct);

  /** Interface to C language function: <br> <code>GLint glGetAttribLocation(GLuint program, const GLchar *  name)</code><br>   */
  public static int glGetAttribLocation(int program, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new RuntimeException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
        return glGetAttribLocation1(program, name, name_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetBooleanv(GLenum pname, GLboolean *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static void glGetBooleanv(int pname, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    glGetBooleanv1(pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct);
  }

  /** Entry point to C language function: <code>void glGetBooleanv(GLenum pname, GLboolean *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native void glGetBooleanv1(int pname, Object data, int data_byte_offset, boolean data_is_direct);

  /** Interface to C language function: <br> <code>void glGetBooleanv(GLenum pname, GLboolean *  data)</code><br>   */
  public static void glGetBooleanv(int pname, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new RuntimeException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    glGetBooleanv1(pname, data, data_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetBufferParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetBufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetBufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetBufferParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetBufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetBufferParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>   */
  public static void glGetBufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetBufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>GLenum glGetError()</code><br>   */
  public static native int glGetError();

  /** Interface to C language function: <br> <code>void glGetFloatv(GLenum pname, GLfloat *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glGetFloatv(int pname, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    glGetFloatv1(pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct);
  }

  /** Entry point to C language function: <code>void glGetFloatv(GLenum pname, GLfloat *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glGetFloatv1(int pname, Object data, int data_byte_offset, boolean data_is_direct);

  /** Interface to C language function: <br> <code>void glGetFloatv(GLenum pname, GLfloat *  data)</code><br>   */
  public static void glGetFloatv(int pname, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new RuntimeException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    glGetFloatv1(pname, data, Buffers.SIZEOF_FLOAT * data_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetFramebufferAttachmentParameteriv1(int target, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *  params)</code><br>   */
  public static void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetIntegerv(GLenum pname, GLint *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetIntegerv(int pname, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    glGetIntegerv1(pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct);
  }

  /** Entry point to C language function: <code>void glGetIntegerv(GLenum pname, GLint *  data)</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetIntegerv1(int pname, Object data, int data_byte_offset, boolean data_is_direct);

  /** Interface to C language function: <br> <code>void glGetIntegerv(GLenum pname, GLint *  data)</code><br>   */
  public static void glGetIntegerv(int pname, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new RuntimeException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    glGetIntegerv1(pname, data, Buffers.SIZEOF_INT * data_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetProgramiv(GLuint program, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetProgramiv(int program, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetProgramiv1(program, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetProgramiv(GLuint program, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetProgramiv1(int program, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetProgramiv(GLuint program, GLenum pname, GLint *  params)</code><br>   */
  public static void glGetProgramiv(int program, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetProgramiv1(program, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static void glGetProgramInfoLog(int program, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    glGetProgramInfoLog1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct);
  }

  /** Entry point to C language function: <code>void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native void glGetProgramInfoLog1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct);

  /** Interface to C language function: <br> <code>void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog)</code><br>   */
  public static void glGetProgramInfoLog(int program, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new RuntimeException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new RuntimeException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    glGetProgramInfoLog1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetRenderbufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetRenderbufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetRenderbufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>   */
  public static void glGetRenderbufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetRenderbufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetShaderiv(GLuint shader, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetShaderiv(int shader, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetShaderiv1(shader, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetShaderiv(GLuint shader, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetShaderiv1(int shader, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetShaderiv(GLuint shader, GLenum pname, GLint *  params)</code><br>   */
  public static void glGetShaderiv(int shader, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetShaderiv1(shader, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static void glGetShaderInfoLog(int shader, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    glGetShaderInfoLog1(shader, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct);
  }

  /** Entry point to C language function: <code>void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native void glGetShaderInfoLog1(int shader, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct);

  /** Interface to C language function: <br> <code>void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog)</code><br>   */
  public static void glGetShaderInfoLog(int shader, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new RuntimeException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new RuntimeException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    glGetShaderInfoLog1(shader, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision)</code><br>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetShaderPrecisionFormat(int shadertype, int precisiontype, IntBuffer range, IntBuffer precision)  {

    final boolean range_is_direct = Buffers.isDirect(range);
    final boolean precision_is_direct = Buffers.isDirect(precision);
    glGetShaderPrecisionFormat1(shadertype, precisiontype, range_is_direct ? range : Buffers.getArray(range), range_is_direct ? Buffers.getDirectBufferByteOffset(range) : Buffers.getIndirectBufferByteOffset(range), range_is_direct, precision_is_direct ? precision : Buffers.getArray(precision), precision_is_direct ? Buffers.getDirectBufferByteOffset(precision) : Buffers.getIndirectBufferByteOffset(precision), precision_is_direct);
  }

  /** Entry point to C language function: <code>void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision)</code><br>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetShaderPrecisionFormat1(int shadertype, int precisiontype, Object range, int range_byte_offset, boolean range_is_direct, Object precision, int precision_byte_offset, boolean precision_is_direct);

  /** Interface to C language function: <br> <code>void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision)</code><br>   */
  public static void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, int range_offset, int[] precision, int precision_offset)  {

    if(range != null && range.length <= range_offset)
      throw new RuntimeException("array offset argument \"range_offset\" (" + range_offset + ") equals or exceeds array length (" + range.length + ")");
    if(precision != null && precision.length <= precision_offset)
      throw new RuntimeException("array offset argument \"precision_offset\" (" + precision_offset + ") equals or exceeds array length (" + precision.length + ")");
    glGetShaderPrecisionFormat1(shadertype, precisiontype, range, Buffers.SIZEOF_INT * range_offset, false, precision, Buffers.SIZEOF_INT * precision_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static void glGetShaderSource(int shader, int bufSize, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    glGetShaderSource1(shader, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct);
  }

  /** Entry point to C language function: <code>void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source)</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native void glGetShaderSource1(int shader, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct);

  /** Interface to C language function: <br> <code>void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source)</code><br>   */
  public static void glGetShaderSource(int shader, int bufSize, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new RuntimeException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new RuntimeException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    glGetShaderSource1(shader, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false);
  }

  /** Interface to C language function: <br> <code>const GLubyte *  glGetString(GLenum name)</code><br>   */
  public static ByteBuffer glGetString(int name)  {

    final ByteBuffer _res;
    _res = glGetString1(name);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code>const GLubyte *  glGetString(GLenum name)</code><br>   */
  private static native ByteBuffer glGetString1(int name);

  /** Interface to C language function: <br> <code>void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glGetTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glGetTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *  params)</code><br>   */
  public static void glGetTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetTexParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetTexParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetTexParameteriv(GLenum target, GLenum pname, GLint *  params)</code><br>   */
  public static void glGetTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetUniformfv(GLuint program, GLint location, GLfloat *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glGetUniformfv(int program, int location, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetUniformfv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetUniformfv(GLuint program, GLint location, GLfloat *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glGetUniformfv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetUniformfv(GLuint program, GLint location, GLfloat *  params)</code><br>   */
  public static void glGetUniformfv(int program, int location, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetUniformfv1(program, location, params, Buffers.SIZEOF_FLOAT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetUniformiv(GLuint program, GLint location, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetUniformiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetUniformiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetUniformiv(GLuint program, GLint location, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetUniformiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetUniformiv(GLuint program, GLint location, GLint *  params)</code><br>   */
  public static void glGetUniformiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetUniformiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>GLint glGetUniformLocation(GLuint program, const GLchar *  name)</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static int glGetUniformLocation(int program, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
        return glGetUniformLocation1(program, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct);
  }

  /** Entry point to C language function: <code>GLint glGetUniformLocation(GLuint program, const GLchar *  name)</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native int glGetUniformLocation1(int program, Object name, int name_byte_offset, boolean name_is_direct);

  /** Interface to C language function: <br> <code>GLint glGetUniformLocation(GLuint program, const GLchar *  name)</code><br>   */
  public static int glGetUniformLocation(int program, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new RuntimeException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
        return glGetUniformLocation1(program, name, name_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glGetVertexAttribfv(int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetVertexAttribfv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glGetVertexAttribfv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *  params)</code><br>   */
  public static void glGetVertexAttribfv(int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetVertexAttribfv1(index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glGetVertexAttribiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glGetVertexAttribiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glGetVertexAttribiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *  params)</code><br>   */
  public static void glGetVertexAttribiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glGetVertexAttribiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glGetVertexAttribPointerv(GLuint index, GLenum pname, void *  *  pointer)</code><br>
      @param pointer a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static void glGetVertexAttribPointerv(int index, int pname, PointerBuffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    glGetVertexAttribPointerv1(index, pname, pointer_is_direct ? ( pointer != null ? pointer.getBuffer() : null ) : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct);
  }

  /** Entry point to C language function: <code>void glGetVertexAttribPointerv(GLuint index, GLenum pname, void *  *  pointer)</code><br>
      @param pointer a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native void glGetVertexAttribPointerv1(int index, int pname, Object pointer, int pointer_byte_offset, boolean pointer_is_direct);

  /** Interface to C language function: <br> <code>void glHint(GLenum target, GLenum mode)</code><br>   */
  public static native void glHint(int target, int mode);

  /** Interface to C language function: <br> <code>GLboolean glIsBuffer(GLuint buffer)</code><br>   */
  public static native byte glIsBuffer(int buffer);

  /** Interface to C language function: <br> <code>GLboolean glIsEnabled(GLenum cap)</code><br>   */
  public static native byte glIsEnabled(int cap);

  /** Interface to C language function: <br> <code>GLboolean glIsFramebuffer(GLuint framebuffer)</code><br>   */
  public static native byte glIsFramebuffer(int framebuffer);

  /** Interface to C language function: <br> <code>GLboolean glIsProgram(GLuint program)</code><br>   */
  public static native byte glIsProgram(int program);

  /** Interface to C language function: <br> <code>GLboolean glIsRenderbuffer(GLuint renderbuffer)</code><br>   */
  public static native byte glIsRenderbuffer(int renderbuffer);

  /** Interface to C language function: <br> <code>GLboolean glIsShader(GLuint shader)</code><br>   */
  public static native byte glIsShader(int shader);

  /** Interface to C language function: <br> <code>GLboolean glIsTexture(GLuint texture)</code><br>   */
  public static native byte glIsTexture(int texture);

  /** Interface to C language function: <br> <code>void glLineWidth(GLfloat width)</code><br>   */
  public static native void glLineWidth(float width);

  /** Interface to C language function: <br> <code>void glLinkProgram(GLuint program)</code><br>   */
  public static native void glLinkProgram(int program);

  /** Interface to C language function: <br> <code>void glPixelStorei(GLenum pname, GLint param)</code><br>   */
  public static native void glPixelStorei(int pname, int param);

  /** Interface to C language function: <br> <code>void glPolygonOffset(GLfloat factor, GLfloat units)</code><br>   */
  public static native void glPolygonOffset(float factor, float units);

  /** Interface to C language function: <br> <code>void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *  pixels)</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public static void glReadPixels(int x, int y, int width, int height, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    glReadPixels1(x, y, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct);
  }

  /** Entry point to C language function: <code>void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *  pixels)</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glReadPixels1(int x, int y, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct);

  /** Interface to C language function: <br> <code>void glReleaseShaderCompiler()</code><br>   */
  public static native void glReleaseShaderCompiler();

  /** Interface to C language function: <br> <code>void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)</code><br>   */
  public static native void glRenderbufferStorage(int target, int internalformat, int width, int height);

  /** Interface to C language function: <br> <code>void glSampleCoverage(GLfloat value, GLboolean invert)</code><br>   */
  public static native void glSampleCoverage(float value, byte invert);

  /** Interface to C language function: <br> <code>void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)</code><br>   */
  public static native void glScissor(int x, int y, int width, int height);

  /** Interface to C language function: <br> <code>void glShaderBinary(GLsizei count, const GLuint *  shaders, GLenum binaryFormat, const void *  binary, GLsizei length)</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public static void glShaderBinary(int count, IntBuffer shaders, int binaryFormat, Buffer binary, int length)  {

    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    glShaderBinary1(count, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, binaryFormat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length);
  }

  /** Entry point to C language function: <code>void glShaderBinary(GLsizei count, const GLuint *  shaders, GLenum binaryFormat, const void *  binary, GLsizei length)</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glShaderBinary1(int count, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int binaryFormat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length);

  /** Interface to C language function: <br> <code>void glShaderBinary(GLsizei count, const GLuint *  shaders, GLenum binaryFormat, const void *  binary, GLsizei length)</code><br>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public static void glShaderBinary(int count, int[] shaders, int shaders_offset, int binaryFormat, Buffer binary, int length)  {

    if(shaders != null && shaders.length <= shaders_offset)
      throw new RuntimeException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    glShaderBinary1(count, shaders, Buffers.SIZEOF_INT * shaders_offset, false, binaryFormat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length);
  }

  /** Interface to C language function: <br> <code>void glShaderSource(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length)</code><br>
      @param string a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glShaderSource(int shader, int count, PointerBuffer string, IntBuffer length)  {

    final boolean string_is_direct = Buffers.isDirect(string);
    final boolean length_is_direct = Buffers.isDirect(length);
    glShaderSource1(shader, count, string_is_direct ? ( string != null ? string.getBuffer() : null ) : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct);
  }

  /** Entry point to C language function: <code>void glShaderSource(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length)</code><br>
      @param string a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glShaderSource1(int shader, int count, Object string, int string_byte_offset, boolean string_is_direct, Object length, int length_byte_offset, boolean length_is_direct);

  /** Interface to C language function: <br> <code>void glShaderSource(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length)</code><br>
      @param string a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static void glShaderSource(int shader, int count, PointerBuffer string, int[] length, int length_offset)  {

    final boolean string_is_direct = Buffers.isDirect(string);
    if(length != null && length.length <= length_offset)
      throw new RuntimeException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    glShaderSource1(shader, count, string_is_direct ? ( string != null ? string.getBuffer() : null ) : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, length, Buffers.SIZEOF_INT * length_offset, false);
  }

  /** Interface to C language function: <br> <code>void glStencilFunc(GLenum func, GLint ref, GLuint mask)</code><br>   */
  public static native void glStencilFunc(int func, int ref, int mask);

  /** Interface to C language function: <br> <code>void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)</code><br>   */
  public static native void glStencilFuncSeparate(int face, int func, int ref, int mask);

  /** Interface to C language function: <br> <code>void glStencilMask(GLuint mask)</code><br>   */
  public static native void glStencilMask(int mask);

  /** Interface to C language function: <br> <code>void glStencilMaskSeparate(GLenum face, GLuint mask)</code><br>   */
  public static native void glStencilMaskSeparate(int face, int mask);

  /** Interface to C language function: <br> <code>void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)</code><br>   */
  public static native void glStencilOp(int fail, int zfail, int zpass);

  /** Interface to C language function: <br> <code>void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)</code><br>   */
  public static native void glStencilOpSeparate(int face, int sfail, int dpfail, int dppass);

  /** Interface to C language function: <br> <code>void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels)</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public static void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct);
  }

  /** Entry point to C language function: <code>void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels)</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct);

  /** Interface to C language function: <br> <code>void glTexParameterf(GLenum target, GLenum pname, GLfloat param)</code><br>   */
  public static native void glTexParameterf(int target, int pname, float param);

  /** Interface to C language function: <br> <code>void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *  params)</code><br>   */
  public static void glTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glTexParameteri(GLenum target, GLenum pname, GLint param)</code><br>   */
  public static native void glTexParameteri(int target, int pname, int param);

  /** Interface to C language function: <br> <code>void glTexParameteriv(GLenum target, GLenum pname, const GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    glTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct);
  }

  /** Entry point to C language function: <code>void glTexParameteriv(GLenum target, GLenum pname, const GLint *  params)</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct);

  /** Interface to C language function: <br> <code>void glTexParameteriv(GLenum target, GLenum pname, const GLint *  params)</code><br>   */
  public static void glTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new RuntimeException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    glTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false);
  }

  /** Interface to C language function: <br> <code>void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels)</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public static void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct);
  }

  /** Entry point to C language function: <code>void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels)</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct);

  /** Interface to C language function: <br> <code>void glUniform1f(GLint location, GLfloat v0)</code><br>   */
  public static native void glUniform1f(int location, float v0);

  /** Interface to C language function: <br> <code>void glUniform1fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glUniform1fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniform1fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniform1fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glUniform1fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniform1fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>   */
  public static void glUniform1fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniform1fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniform1i(GLint location, GLint v0)</code><br>   */
  public static native void glUniform1i(int location, int v0);

  /** Interface to C language function: <br> <code>void glUniform1iv(GLint location, GLsizei count, const GLint *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glUniform1iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniform1iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniform1iv(GLint location, GLsizei count, const GLint *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glUniform1iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniform1iv(GLint location, GLsizei count, const GLint *  value)</code><br>   */
  public static void glUniform1iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniform1iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniform2f(GLint location, GLfloat v0, GLfloat v1)</code><br>   */
  public static native void glUniform2f(int location, float v0, float v1);

  /** Interface to C language function: <br> <code>void glUniform2fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glUniform2fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniform2fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniform2fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glUniform2fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniform2fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>   */
  public static void glUniform2fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniform2fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniform2i(GLint location, GLint v0, GLint v1)</code><br>   */
  public static native void glUniform2i(int location, int v0, int v1);

  /** Interface to C language function: <br> <code>void glUniform2iv(GLint location, GLsizei count, const GLint *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glUniform2iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniform2iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniform2iv(GLint location, GLsizei count, const GLint *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glUniform2iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniform2iv(GLint location, GLsizei count, const GLint *  value)</code><br>   */
  public static void glUniform2iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniform2iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)</code><br>   */
  public static native void glUniform3f(int location, float v0, float v1, float v2);

  /** Interface to C language function: <br> <code>void glUniform3fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glUniform3fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniform3fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniform3fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glUniform3fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniform3fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>   */
  public static void glUniform3fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniform3fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)</code><br>   */
  public static native void glUniform3i(int location, int v0, int v1, int v2);

  /** Interface to C language function: <br> <code>void glUniform3iv(GLint location, GLsizei count, const GLint *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glUniform3iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniform3iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniform3iv(GLint location, GLsizei count, const GLint *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glUniform3iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniform3iv(GLint location, GLsizei count, const GLint *  value)</code><br>   */
  public static void glUniform3iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniform3iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)</code><br>   */
  public static native void glUniform4f(int location, float v0, float v1, float v2, float v3);

  /** Interface to C language function: <br> <code>void glUniform4fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glUniform4fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniform4fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniform4fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glUniform4fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniform4fv(GLint location, GLsizei count, const GLfloat *  value)</code><br>   */
  public static void glUniform4fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniform4fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)</code><br>   */
  public static native void glUniform4i(int location, int v0, int v1, int v2, int v3);

  /** Interface to C language function: <br> <code>void glUniform4iv(GLint location, GLsizei count, const GLint *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void glUniform4iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniform4iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniform4iv(GLint location, GLsizei count, const GLint *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void glUniform4iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniform4iv(GLint location, GLsizei count, const GLint *  value)</code><br>   */
  public static void glUniform4iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniform4iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glUniformMatrix2fv(int location, int count, byte transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniformMatrix2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glUniformMatrix2fv1(int location, int count, byte transpose, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>   */
  public static void glUniformMatrix2fv(int location, int count, byte transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniformMatrix2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glUniformMatrix3fv(int location, int count, byte transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniformMatrix3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glUniformMatrix3fv1(int location, int count, byte transpose, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>   */
  public static void glUniformMatrix3fv(int location, int count, byte transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniformMatrix3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glUniformMatrix4fv(int location, int count, byte transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    glUniformMatrix4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glUniformMatrix4fv1(int location, int count, byte transpose, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)</code><br>   */
  public static void glUniformMatrix4fv(int location, int count, byte transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    glUniformMatrix4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false);
  }

  /** Interface to C language function: <br> <code>void glUseProgram(GLuint program)</code><br>   */
  public static native void glUseProgram(int program);

  /** Interface to C language function: <br> <code>void glValidateProgram(GLuint program)</code><br>   */
  public static native void glValidateProgram(int program);

  /** Interface to C language function: <br> <code>void glVertexAttrib1f(GLuint index, GLfloat x)</code><br>   */
  public static native void glVertexAttrib1f(int index, float x);

  /** Interface to C language function: <br> <code>void glVertexAttrib1fv(GLuint index, const GLfloat *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glVertexAttrib1fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    glVertexAttrib1fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct);
  }

  /** Entry point to C language function: <code>void glVertexAttrib1fv(GLuint index, const GLfloat *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glVertexAttrib1fv1(int index, Object v, int v_byte_offset, boolean v_is_direct);

  /** Interface to C language function: <br> <code>void glVertexAttrib1fv(GLuint index, const GLfloat *  v)</code><br>   */
  public static void glVertexAttrib1fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new RuntimeException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    glVertexAttrib1fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false);
  }

  /** Interface to C language function: <br> <code>void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)</code><br>   */
  public static native void glVertexAttrib2f(int index, float x, float y);

  /** Interface to C language function: <br> <code>void glVertexAttrib2fv(GLuint index, const GLfloat *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glVertexAttrib2fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    glVertexAttrib2fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct);
  }

  /** Entry point to C language function: <code>void glVertexAttrib2fv(GLuint index, const GLfloat *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glVertexAttrib2fv1(int index, Object v, int v_byte_offset, boolean v_is_direct);

  /** Interface to C language function: <br> <code>void glVertexAttrib2fv(GLuint index, const GLfloat *  v)</code><br>   */
  public static void glVertexAttrib2fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new RuntimeException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    glVertexAttrib2fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false);
  }

  /** Interface to C language function: <br> <code>void glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)</code><br>   */
  public static native void glVertexAttrib3f(int index, float x, float y, float z);

  /** Interface to C language function: <br> <code>void glVertexAttrib3fv(GLuint index, const GLfloat *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glVertexAttrib3fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    glVertexAttrib3fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct);
  }

  /** Entry point to C language function: <code>void glVertexAttrib3fv(GLuint index, const GLfloat *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glVertexAttrib3fv1(int index, Object v, int v_byte_offset, boolean v_is_direct);

  /** Interface to C language function: <br> <code>void glVertexAttrib3fv(GLuint index, const GLfloat *  v)</code><br>   */
  public static void glVertexAttrib3fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new RuntimeException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    glVertexAttrib3fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false);
  }

  /** Interface to C language function: <br> <code>void glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)</code><br>   */
  public static native void glVertexAttrib4f(int index, float x, float y, float z, float w);

  /** Interface to C language function: <br> <code>void glVertexAttrib4fv(GLuint index, const GLfloat *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void glVertexAttrib4fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    glVertexAttrib4fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct);
  }

  /** Entry point to C language function: <code>void glVertexAttrib4fv(GLuint index, const GLfloat *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void glVertexAttrib4fv1(int index, Object v, int v_byte_offset, boolean v_is_direct);

  /** Interface to C language function: <br> <code>void glVertexAttrib4fv(GLuint index, const GLfloat *  v)</code><br>   */
  public static void glVertexAttrib4fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new RuntimeException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    glVertexAttrib4fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false);
  }

  /** Interface to C language function: <br> <code>void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer)</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public static void glVertexAttribPointer(int index, int size, int type, byte normalized, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    glVertexAttribPointer1(index, size, type, normalized, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct);
  }

  /** Entry point to C language function: <code>void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer)</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private static native void glVertexAttribPointer1(int index, int size, int type, byte normalized, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct);

  /** Interface to C language function: <br> <code>void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)</code><br>   */
  public static native void glViewport(int x, int y, int width, int height);

} // end of class AngleNative
